# -*- coding: utf-8 -*-
"""games.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dehsF9Z2-kVg0Uf_cIO5-sqkUENO0Xkg
"""

import numpy
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import sys


def setTowers(total_disks):
    global TOWERS
    global TOTAL_DISKS
    TOTAL_DISKS = total_disks
    # Populate Tower A:
    TOWERS = {'A': list(reversed(range(1, TOTAL_DISKS + 1))),
             'B': [],
             'C': []}


def printDisk(diskNum):
    # Print a single disk of width diskNum.
    global TOTAL_DISKS
    emptySpace = ' ' * (TOTAL_DISKS - diskNum)
    if diskNum == 0:
        # Just draw the pole.
        sys.stdout.write(emptySpace + '||' + emptySpace)
    else:
        # Draw the disk.
        diskSpace = '@' * diskNum
        diskNumLabel = str(diskNum).rjust(2, '_')
        sys.stdout.write(emptySpace + diskSpace + diskNumLabel + diskSpace + emptySpace)


def printTowers():
    global TOWERS
    global TOTAL_DISKS
    # Print all three towers.
    for level in range(TOTAL_DISKS, -1, -1):
        for tower in (TOWERS['A'], TOWERS['B'], TOWERS['C']):
            if level >= len(tower):
                printDisk(0)
            else:
                printDisk(tower[level])
        sys.stdout.write('\n')
    # Print the tower labels A, B, and C.
    emptySpace = ' ' * (TOTAL_DISKS)
    print('%s A%s%s B%s%s C\n' % (emptySpace, emptySpace, emptySpace, emptySpace, emptySpace))


def moveOneDisk(startTower, endTower):
    # Move the top disk from startTower to endTower.
    global TOWERS
    disk = TOWERS[startTower].pop()
    TOWERS[endTower].append(disk)


def solve(numberOfDisks, startTower, endTower, tempTower):
    # Move the top numberOfDisks disks from startTower to endTower.
    if numberOfDisks == 1:
        # BASE CASE
        moveOneDisk(startTower, endTower)
        printTowers()
        return
    else:
        # RECURSIVE CASE
        solve(numberOfDisks - 1, startTower, tempTower, endTower)
        moveOneDisk(startTower, endTower)
        printTowers()
        solve(numberOfDisks - 1, tempTower, endTower, startTower)
        return

def playTowers():
    while True:
          printTowers()
          print('''Введите две буквы подряд:
          одну букву для башни-старт, а другую букву для башни-финиш (буквы A, B или C).
          Чтобы закончить игру - введите букву Q.\n''')
          move = input().upper()
          if move == 'Q':
             break
          elif move[0] in 'ABC' and move[1] in 'ABC' and move[0] != move[1]:
               moveOneDisk(move[0], move[1])


def life(N = 100, interval = 200, count = 200, w = 8, h = 8):
    global grid
    ON = 255
    OFF = 0
    vals = [ON, OFF]

    # populate grid with random on/off - more off than on
    grid = numpy.random.choice(vals, N*N, p=[0.2, 0.8]).reshape(N, N)

    def update(data):
        global grid
        # copy grid since we require 8 neighbors for calculation
        # and we go line by line
        newGrid = grid.copy()
        for i in range(N):
            for j in range(N):
            # compute 8-neghbor sum
            # using toroidal boundary conditions - x and y wrap around
            # so that the simulaton takes place on a toroidal surface.
                total = (grid[i, (j-1)%N] + grid[i, (j+1)%N] +
                        grid[(i-1)%N, j] + grid[(i+1)%N, j] +
                        grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
                        grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255
                # apply Conway's rules
                if grid[i, j]  == ON:
                   if (total < 2) or (total > 3):
                      newGrid[i, j] = OFF
                else:
                   if total == 3:
                      newGrid[i, j] = ON
        # update data
        mat.set_data(newGrid)
        grid = newGrid
        return [mat]

    # set up animation
    width, height = w, h
    fig = plt.figure(figsize = (width, height))
    ax = plt.axes()

    mat = ax.matshow(grid)
    ani = animation.FuncAnimation(fig, update, interval=interval,
                                  save_count=count)

    return ani