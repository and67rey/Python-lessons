# -*- coding: utf-8 -*-
"""fractals.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FQRVLS7PXIf4VbD4sKO2a3okrsSgg1Zu
"""

import numpy
import math
import matplotlib.pyplot as plt
from matplotlib import collections as mc
import matplotlib.animation as animation
from matplotlib import rc
from PIL import Image


def julia_calc(zx, zy, cx, cy, threshold):
    """Calculates whether the number z[0] = zx + i*zy with a constant c = x + i*y
    belongs to the Julia set. In order to belong, the sequence
    z[i + 1] = z[i]**2 + c, must not diverge after 'threshold' number of steps.
    The sequence diverges if the absolute value of z[i+1] is greater than 4.

    :param float zx: the x component of z[0]
    :param float zy: the y component of z[0]
    :param float cx: the x component of the constant c
    :param float cy: the y component of the constant c
    :param int threshold: the number of iterations to considered it converged
    """
    # initial conditions
    z = complex(zx, zy)
    c = complex(cx, cy)

    for i in range(threshold):
        z = z**2 + c
        if abs(z) > 4.:  # it diverged
            return i

    return threshold - 1  # it didn't diverge


def julia():

    x_start, y_start = -2, -2  # an interesting region starts here
    width, height = 4, 4  # for 4 units up and right
    density_per_unit = 200  # how many pixles per unit

    # real and imaginary axis
    re = numpy.linspace(x_start, x_start + width, width * density_per_unit )
    im = numpy.linspace(y_start, y_start + height, height * density_per_unit)

    threshold = 20  # max allowed iterations
    frames = 100  # number of frames in the animation

    # we represent c as c = r*cos(a) + i*r*sin(a) = r*e^{i*a}
    r = 0.7885
    a = numpy.linspace(0, 2*numpy.pi, frames)

    fig = plt.figure(figsize=(10, 10))  # instantiate a figure to draw
    ax = plt.axes()  # create an axes object

    def animate(i):
        ax.clear()  # clear axes object
        ax.set_xticks([], [])  # clear x-axis ticks
        ax.set_yticks([], [])  # clear y-axis ticks

        X = numpy.empty((len(re), len(im)))  # the initial array-like image
        cx, cy = r * numpy.cos(a[i]), r * numpy.sin(a[i])  # the initial c number

        # iterations for the given threshold
        for i in range(len(re)):
            for j in range(len(im)):
                X[i, j] = julia_calc(re[i], im[j], cx, cy, threshold)

        img = ax.imshow(X.T, interpolation="bicubic", cmap='magma')
        return [img]

    ani = animation.FuncAnimation(fig, animate, frames=frames, interval=50, blit=True)

    # Эта строка нужна для отображения созданной анимации в Colab
    # rc('animation', html='jshtml')
    return ani


def mandelbrot_calc(x, y, threshold):
    """Calculates whether the number c = x + i*y belongs to the
    Mandelbrot set. In order to belong, the sequence z[i + 1] = z[i]**2 + c
    must not diverge after 'threshold' number of steps. The sequence diverges
    if the absolute value of z[i+1] is greater than 4.

    :param float x: the x component of the initial complex number
    :param float y: the y component of the initial complex number
    :param int threshold: the number of iterations to considered it converged
    """
    # initial conditions
    c = complex(x, y)
    z = complex(0, 0)

    for i in range(threshold):
        z = z**2 + c
        if abs(z) > 4.:  # it diverged
            return i

    return threshold - 1  # it didn't diverge


def mandelbrot():

    x_start, y_start = -2, -1.5  # an interesting region starts here
    width, height = 3, 3  # for 3 units up and right
    density_per_unit = 250  # how many pixles per unit

    # real and imaginary axis
    re = numpy.linspace(x_start, x_start + width, width * density_per_unit )
    im = numpy.linspace(y_start, y_start + height, height * density_per_unit)

    fig = plt.figure(figsize=(10, 10))  # instantiate a figure to draw
    ax = plt.axes()  # create an axes object

    def animate(i):
        ax.clear()  # clear axes object
        ax.set_xticks([], [])  # clear x-axis ticks
        ax.set_yticks([], [])  # clear y-axis ticks

        X = numpy.empty((len(re), len(im)))  # re-initialize the array-like image
        threshold = round(1.15**(i + 1))  # calculate the current threshold

        # iterations for the current threshold
        for i in range(len(re)):
            for j in range(len(im)):
                X[i, j] = mandelbrot_calc(re[i], im[j], threshold)

        # associate colors to the iterations with an iterpolation
        img = ax.imshow(X.T, interpolation="bicubic", cmap='magma')

        return [img]

    ani = animation.FuncAnimation(fig, animate, frames=45, interval=120, blit=True)

    # rc('animation', html='jshtml')
    return ani


def sierpinski_triangle(n) :

    y = n - 1
    while(y >= 0) :

        # printing space till
        # the value of y
        i = 0
        while(i < y ):
            print(" ",end="")
            i = i + 1

        # printing '*'
        x = 0
        while(x + y < n ):

            # printing '*' at the appropriate
            # position is done by the and
            # value of x and y wherever value
            # is 0 we have printed '*'
            if ((x & y) != 0) :
                print(" ", end = " ")
            else :
                print("* ", end = "")
            x =x + 1

        print()
        y = y - 1


def array_to_file(array, filename):
        Image.fromarray(array).save(filename)


def sierpinski_square(filename, level=5):

    size = 3**level

    # creating an image
    square = numpy.empty([size, size, 3], dtype = numpy.uint8)
    color = numpy.array([255, 255, 255], dtype = numpy.uint8)

    # filling it black
    square.fill(0)

    for i in range(0, level + 1):
        stepdown = 3**(level - i)
        for x in range(0, 3**i):

            # checking for the centremost square
            if x % 3 == 1:
                for y in range(0, 3**i):
                    if y % 3 == 1:

                        # changing its color
                        square[y * stepdown:(y + 1)*stepdown, x * stepdown:(x + 1)*stepdown] = color

    array_to_file(square, filename)

    return square


def resize_image(factor, filename, resized_name):
    with Image.open(filename) as im:
          (width, height) = (int(im.width * factor), int(im.height * factor))
          im_resized = im.resize((width, height))
          im_resized.save(resized_name)


def plot_segments(segments, w, h):

    fig = plt.figure(figsize = (w, h))
    ax = plt.axes()
    lines = mc.LineCollection(segments)
    ax.add_collection(lines)
    ax.margins(0.2)
    ax.set_aspect('equal')
    ax.autoscale()
    return ax

def f(seg):
    a = seg[0]
    e = seg[1]
    b = ((2*a[0]+e[0])/3, (2*a[1]+e[1])/3)
    d = ((a[0]+2*e[0])/3, (a[1]+2*e[1])/3)
    k = math.sqrt(3)/6
    c = ((a[0]+e[0])/2 - k * (e[1]-a[1]), (a[1]+e[1])/2 + k *(e[0]-a[0]))
    return [(a,b), (b,c), (c,d), (d,e)]

def recurse(segments):
    return [x for s in segments for x in f(s)]

def snowflake(n, w=12, h=12):
    p = -math.cos(math.pi/6), math.sin(math.pi/6)
    q = math.cos(math.pi/6), math.sin(5*math.pi/6)
    r = 0.0, -1.0
    segments = [(p,q), (q,r), (r,p)]
    for i in range(n):
        segments = recurse(segments)
    plot_segments(segments, w, h)