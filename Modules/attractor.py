# -*- coding: utf-8 -*-
"""attractor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LjlaS3RBFuXeNl9t7Oc5aNri7remUp85
"""

import numpy as np
from scipy import integrate
from matplotlib import pyplot as plt
from matplotlib.colors import cnames
from matplotlib import animation
from matplotlib.animation import FuncAnimation
from matplotlib.animation import FFMpegWriter
from IPython.display import HTML
from base64 import b64encode


# Функция для создания трехмерного массива точек для Аттрактора Лоренца
def lorenz_array(xyz, *, s=10, r=28, b=2.667):

    x, y, z = xyz
    x_dot = s*(y - x)
    y_dot = r*x - y - x*z
    z_dot = x*y - b*z

    return np.array([x_dot, y_dot, z_dot])


def lorentz_classic(w, h):
    dt = 0.01
    num_steps = 10000

    xyzs = np.empty((num_steps + 1, 3))

    # Определим начальные значения
    xyzs[0] = (0., 1., 1.05)

    # Получим значения для всех точек Аттрактора Лоренца в 3D
    for i in range(num_steps):
             xyzs[i + 1] = xyzs[i] + lorenz_array(xyzs[i]) * dt


    plt.style.use('seaborn-v0_8-whitegrid')

    width, height = w, h
    fig = plt.figure(figsize = (width, height))
    ax = plt.axes(projection='3d')

    lorenz_plot = ax.plot(*xyzs.T, lw=0.5)
    ax.set_xlabel("Ось X")
    ax.set_ylabel("Ось Y")
    ax.set_zlabel("Ось Z")
    title = ax.set_title("Аттрактор Лоренца")

    return fig


def lorentz_custom(w, h, s=10, r=28, b=2.667):
    dt = 0.01
    num_steps = 10000

    xyzs = np.empty((num_steps + 1, 3))

    # Определим начальные значения
    xyzs[0] = (0., 1., 1.05)

    # Получим значения для всех точек Аттрактора Лоренца в 3D
    for i in range(num_steps):
             xyzs[i + 1] = xyzs[i] + lorenz_array(xyzs[i], s=s, r=r, b=b) * dt


    plt.style.use('seaborn-v0_8-whitegrid')

    width, height = w, h
    fig = plt.figure(figsize = (width, height))
    ax = plt.axes(projection='3d')

    lorenz_plot = ax.plot(*xyzs.T, lw=0.5)
    ax.set_xlabel("Ось X")
    ax.set_ylabel("Ось Y")
    ax.set_zlabel("Ось Z")
    title = ax.set_title("Аттрактор Лоренца")

    return fig


def lorentz_deriv(params, t0, sigma=10., beta=8./3, rho=28.0):
    x, y, z = params
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]



def lorentz_animation(N = 20, frames = 1000):

    # Выбор начальных точек случайным образом в диапазоне от -15 до +15
    np.random.seed(1)
    x0 = -15 + 30 * np.random.random((N, 3))

    # Задание набора значений для временной шкалы
    t = np.linspace(0, 12, 2000)

    # Получение решений для траекторий точек
    x_t = np.asarray([integrate.odeint(lorentz_deriv, x0i, t)
                     for x0i in x0])

    # Создание картинки и осей для анимации
    width, height = 8, 6
    fig = plt.figure(figsize = (width, height))
    ax = plt.axes(projection='3d')
    ax.axis('off')

    # Выбор разных цветов для разных траекторий
    colors = plt.cm.jet(np.linspace(0, 1, N))

    # Начальные устанановки для линий и точек
    lines = sum([ax.plot([], [], [], '-', c=c)
                 for c in colors], [])
    pts = sum([ax.plot([], [], [], 'o', c=c)
              for c in colors], [])

    # Границы диапазонов для очей x, y, z
    ax.set_xlim((-25, 25))
    ax.set_ylim((-35, 35))
    ax.set_zlim((5, 55))

    # Начальные значения для углов обзора 3D графика
    ax.view_init(30, 0)

    # Функция для создания начального кадра
    def init():
        for line, pt in zip(lines, pts):
            line.set_data([], [])
            line.set_3d_properties([])

            pt.set_data([], [])
            pt.set_3d_properties([])
        return lines + pts

    # Функция для создания чередующихся кадров анимации
    def animate(i):
        # Два временных интервала для одного кадра
        i = (2 * i) % x_t.shape[1]

        for line, pt, xi in zip(lines, pts, x_t):
            x, y, z = xi[:i].T

            line.set_data(x, y)
            line.set_3d_properties(z)

            pt.set_data(x[-1:], y[-1:])
            pt.set_3d_properties(z[-1:])

        ax.view_init(30, 0.3 * i)
        fig.canvas.draw()
        return lines + pts

    # Создание анимации с помощью FuncAnimation
    anim = FuncAnimation(fig, animate, init_func=init,
                               frames=frames, interval=20, blit=True)

    return anim


def ani_to_mp4(filename, anim):

    # Запись анимации в видеофайл формата mp4
    writer = FFMpegWriter(fps=15, bitrate=1800)
    anim.save(filename, writer=writer)


def play_mp4(filename):

    mp4 = open(filename,'rb').read()
    data_url = "data:video/mp4;base64," + b64encode(mp4).decode()
    html_play = HTML("""
               <video width=800 controls>
               <source src="%s" type="video/mp4">
               </video>
               """ % data_url)

    return html_play